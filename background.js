// Background Script v2.0
// Arka plan i≈ülemleri, periyodik kontroller, bildirimler

(function() {
  'use strict';
  
  const logger = PriceTrackerHelpers.createLogger('Background');
  
  // Ayarlar
  const DEFAULT_SETTINGS = {
    checkInterval: 30, // dakika
    notifications: true,
    notifyOnPriceUp: false,
    notifyOnPriceDown: true,
    autoCheck: true,
    maxRetries: 3,
    rateLimitPerHour: 100
  };
  
  let settings = null;
  let rateLimiter = null;
  
  // Request deduplication - prevent multiple fetches to same URL
  const pendingRequests = new Map();
  
  // Initialize
  async function initialize() {
    logger.info('Initializing background script...');
    
    // Ayarlarƒ± y√ºkle
    settings = await PriceTrackerHelpers.getStorage('settings', DEFAULT_SETTINGS);
    
    // Rate limiter olu≈ütur
    rateLimiter = PriceTrackerHelpers.createRateLimiter(
      settings.rateLimitPerHour,
      60 * 60 * 1000 // 1 saat
    );
    
    // Alarm'ƒ± kur
    if (settings.autoCheck) {
      setupAlarm();
    }
    
    logger.success('Background script initialized');
  }
  
  // Alarm kur - D√úZELTƒ∞LDƒ∞
  function setupAlarm() {
    // √ñnce mevcut alarm'ƒ± temizle
    browser.alarms.clear('checkPrices').then(() => {
      // Yeni alarm kur
      browser.alarms.create('checkPrices', {
        periodInMinutes: settings.checkInterval,
        when: Date.now() + 60000 // 1 dakika sonra ilk √ßalƒ±≈üma
      });
      
      logger.info(`‚úÖ Alarm kuruldu: Her ${settings.checkInterval} dakikada bir kontrol`);
    });
  }
  
  // Alarm tetiklendiƒüinde
  browser.alarms.onAlarm.addListener(async (alarm) => {
    if (alarm.name === 'checkPrices') {
      logger.info('‚è∞ Automatic price check triggered');
      await checkAllPrices();
    }
  });
  
  // T√ºm √ºr√ºnlerin fiyatlarƒ±nƒ± kontrol et
  async function checkAllPrices() {
    const products = await PriceTrackerHelpers.getStorage('trackedProducts', []);
    
    if (products.length === 0) {
      logger.info('No products to check');
      return { checked: 0, updated: 0, errors: 0 };
    }
    
    logger.info(`Checking ${products.length} products...`);
    
    let checked = 0;
    let updated = 0;
    let errors = 0;
    
    // Her √ºr√ºn√º kontrol et (paralel, ama rate limit'e dikkat)
    const checkPromises = products.map((product, index) => 
      checkProductWithDelay(product, index * 2000) // Her √ºr√ºn i√ßin 2sn delay
    );
    
    const results = await Promise.allSettled(checkPromises);
    
    // Sonu√ßlarƒ± i≈üle
    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      
      if (result.status === 'fulfilled' && result.value) {
        const { updated: wasUpdated, product: updatedProduct } = result.value;
        
        if (updatedProduct) {
          products[i] = updatedProduct;
          checked++;
          
          if (wasUpdated) {
            updated++;
          }
        }
      } else {
        errors++;
        logger.error(`Error checking product ${i}:`, result.reason);
      }
    }
    
    // G√ºncellenen √ºr√ºnleri kaydet
    if (updated > 0) {
      await PriceTrackerHelpers.setStorage('trackedProducts', products);
    }
    
    logger.success(`Check complete: ${checked} checked, ${updated} updated, ${errors} errors`);
    
    return { checked, updated, errors };
  }
  
  // √úr√ºn√º delay ile kontrol et
  async function checkProductWithDelay(product, delay) {
    await PriceTrackerHelpers.wait(delay);
    return await checkSingleProduct(product);
  }
  
  // Tek bir √ºr√ºn√º kontrol et - D√úZELTƒ∞LDƒ∞
  async function checkSingleProduct(product) {
    try {
      // Rate limit kontrol√º
      try {
        await rateLimiter.checkLimit();
      } catch (rateLimitError) {
        logger.warn('Rate limit reached, waiting...');
        await PriceTrackerHelpers.wait(2000);
      }
      
      logger.info(`Checking: ${PriceTrackerHelpers.truncate(product.name, 40)}`);
      
      // Fiyatƒ± √ßek
      const newPriceData = await fetchProductPrice(product.url);
      
      if (!newPriceData || !newPriceData.price || isNaN(newPriceData.price)) {
        logger.warn(`Could not fetch price for: ${product.site}`);
        // Yine de √ºr√ºn√º d√∂nd√ºr (lastCheck g√ºncellemek i√ßin)
        product.lastCheck = Date.now();
        return { updated: false, product: product };
      }
      
      const newPrice = newPriceData.price;
      const oldPrice = product.price;
      const hasChanged = Math.abs(newPrice - oldPrice) > 0.01;
      
      if (hasChanged) {
        logger.info(`Price changed: ${oldPrice} ‚Üí ${newPrice} ${product.currency}`);
        
        // Fiyat ge√ßmi≈üini g√ºncelle
        if (!product.priceHistory) {
          product.priceHistory = [];
        }
        
        product.priceHistory.push({
          price: oldPrice,
          date: product.lastCheck || Date.now()
        });
        
        // Maksimum 30 ge√ßmi≈ü fiyat tut
        if (product.priceHistory.length > 30) {
          product.priceHistory = product.priceHistory.slice(-30);
        }
        
        // √úr√ºn√º g√ºncelle - ESKƒ∞ Fƒ∞YATI previousPrice'a kaydet
        product.previousPrice = oldPrice;  // Eski fiyat
        product.price = newPrice;          // Yeni fiyat (g√ºncel)
        product.lastCheck = Date.now();
        
        // √úr√ºn adƒ±nƒ± da g√ºncelle (deƒüi≈ümi≈ü olabilir)
        if (newPriceData.name && newPriceData.name.length > 10) {
          product.name = newPriceData.name;
        }
        
        // Bildirim g√∂nder
        if (settings.notifications) {
          await sendPriceNotification(product, oldPrice, newPrice);
        }
        
        return { updated: true, product };
      } else {
        // Fiyat deƒüi≈ümedi, sadece lastCheck'i g√ºncelle
        product.lastCheck = Date.now();
        return { updated: false, product };
      }
      
    } catch (error) {
      logger.error(`Error checking product:`, error);
      throw error;
    }
  }
  
  // √úr√ºn fiyatƒ±nƒ± fetch et - D√úZELTƒ∞LDƒ∞: Daha fazla bilgi d√∂nd√ºr + Request deduplication
  async function fetchProductPrice(url) {
    // Check if request is already pending for this URL
    if (pendingRequests.has(url)) {
      logger.info(`Reusing pending request for ${url}`);
      return await pendingRequests.get(url);
    }
    
    // Create new request promise
    const requestPromise = (async () => {
      try {
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'tr-TR,tr;q=0.9,en-US;q=0.8,en;q=0.7',
            'Cache-Control': 'no-cache'
          },
          cache: 'no-store'
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        
        const html = await response.text();
        
        // Basit DOM parser
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // PriceParser ile extract et
        const productInfo = await PriceParser.extractProductInfo(doc, url);
        
        return productInfo; // T√ºm bilgiyi d√∂nd√ºr (price, name, vb.)
        
      } catch (error) {
        logger.error('Fetch error:', error);
        return null;
      } finally {
        // Clean up pending request
        pendingRequests.delete(url);
      }
    })();
    
    // Store pending request
    pendingRequests.set(url, requestPromise);
    
    return await requestPromise;
  }
  
  // Fiyat bildirimi g√∂nder
  async function sendPriceNotification(product, oldPrice, newPrice) {
    const change = PriceTrackerHelpers.calculateChange(oldPrice, newPrice);
    
    // Ayarlara g√∂re bildirim g√∂nder mi?
    if (change.isIncrease && !settings.notifyOnPriceUp) {
      return;
    }
    if (change.isDecrease && !settings.notifyOnPriceDown) {
      return;
    }
    
    const title = change.isDecrease ? 'üéâ Fiyat D√º≈üt√º!' : 'üìà Fiyat Arttƒ±';
    const icon = change.isDecrease ? 'üîª' : 'üî∫';
    
    const message = [
      PriceTrackerHelpers.truncate(product.name, 50),
      `${oldPrice.toFixed(2)} ‚Üí ${newPrice.toFixed(2)} ${product.currency}`,
      `${icon} ${change.percentFormatted}`
    ].join('\n');
    
    await browser.notifications.create({
      type: 'basic',
      iconUrl: browser.runtime.getURL('icons/icon48.png'),
      title: title,
      message: message,
      priority: change.isDecrease ? 2 : 1
    });
    
    logger.info('Notification sent');
  }
  
  // Message handler
  browser.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.action === 'checkAllPrices') {
      checkAllPrices()
        .then(result => sendResponse(result))
        .catch(error => sendResponse({ error: error.message }));
      return true;
    }
    
    if (request.action === 'checkSingleProduct') {
      checkSingleProduct(request.product)
        .then(result => sendResponse(result))
        .catch(error => sendResponse({ error: error.message }));
      return true;
    }
    
    if (request.action === 'updateSettings') {
      settings = { ...settings, ...request.settings };
      PriceTrackerHelpers.setStorage('settings', settings)
        .then(() => {
          if (request.settings.checkInterval) {
            setupAlarm();
          }
          sendResponse({ success: true });
        });
      return true;
    }
    
    if (request.action === 'getSettings') {
      sendResponse(settings);
      return true;
    }
    
    if (request.action === 'productDetected') {
      // Content script'ten gelen bilgi - ≈üimdilik logla
      logger.info('Product detected on page:', request.product.name);
      sendResponse({ received: true });
      return true;
    }
  });
  
  // Extension y√ºklendiƒüinde
  browser.runtime.onInstalled.addListener((details) => {
    if (details.reason === 'install') {
      logger.success('üéâ Price Tracker Pro installed!');
      
      // Welcome notification
      browser.notifications.create({
        type: 'basic',
        iconUrl: browser.runtime.getURL('icons/icon48.png'),
        title: 'Fiyat Takip√ßisi Pro',
        message: 'Eklenti ba≈üarƒ±yla kuruldu! Bir √ºr√ºn sayfasƒ±na gidip takibe alabilirsiniz.'
      });
      
    } else if (details.reason === 'update') {
      logger.success(`Updated to version ${browser.runtime.getManifest().version}`);
    }
    
    initialize();
  });
  
  // Startup'ta initialize et
  browser.runtime.onStartup.addListener(() => {
    logger.info('Browser started');
    initialize();
  });
  
  // ƒ∞lk y√ºkleme
  initialize();
  
})();